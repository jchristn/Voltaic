# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Voltaic is a JSON-RPC 2.0 implementation for .NET 8.0 that provides both client and server functionality over TCP sockets. The solution is structured as a library with test applications demonstrating client-server communication.

## Solution Structure

- **Voltaic** (src/Voltaic/): Core library containing JSON-RPC 2.0 protocol implementation
  - `JsonRpcRequest.cs`: Request message model
  - `JsonRpcResponse.cs`: Response message model
  - `JsonRpcError.cs`: Error object with standard JSON-RPC error codes
  - `JsonRpcServer.cs`: TCP-based server implementation with JsonRpcServer class
  - `JsonRpcClient.cs`: TCP-based client implementation with JsonRpcClient class
  - `MessageFraming.cs`: LSP-style message framing utilities (internal static class)
- **Test.Server** (src/Test.Server/): Interactive server application for manual testing
- **Test.Client** (src/Test.Client/): Interactive client application for manual testing
- **Test.Automated** (src/Test.Automated/): Comprehensive automated test suite

Note: All core library classes use the `Voltaic` namespace.

## Build Commands

```bash
# Build entire solution
dotnet build src/Voltaic.sln

# Build specific project
dotnet build src/Voltaic/Voltaic.csproj
dotnet build src/Test.Server/Test.Server.csproj
dotnet build src/Test.Client/Test.Client.csproj

# Build for release
dotnet build src/Voltaic.sln -c Release
```

## Running Tests

```bash
# Run automated test suite
dotnet run --project src/Test.Automated/Test.Automated.csproj

# The test suite covers:
# - Basic message tests (echo, sequential requests)
# - Partial read tests (single-byte transmission)
# - Multiple messages in single packet
# - Large message handling (1MB+)
# - Malformed header handling
# - Connection drop scenarios
# - High load tests (100 rapid requests)
# - Client-server integration (notifications, broadcasts)
```

## Running Interactive Test Applications

```bash
# Start interactive server (requires port argument)
dotnet run --project src/Test.Server/Test.Server.csproj -- 8080

# Start interactive client (requires port argument)
dotnet run --project src/Test.Client/Test.Client.csproj -- 8080
```

## Architecture Notes

### JSON-RPC Protocol Implementation

The implementation follows JSON-RPC 2.0 specification:
- **Requests** have an optional `id` field - when omitted, they become notifications (no response expected)
- **Responses** must include the matching `id` from the request
- **Built-in error codes** are provided via static factory methods in `JsonRpcError`

### Server Architecture (JsonRpcServer.cs)

- Implements `IDisposable` for proper resource cleanup
- Uses `TcpListener` to accept connections on a specified port
- Maintains concurrent connections in a `ConcurrentDictionary<string, ClientConnection>`
- Each client is assigned a unique ID (`client_1`, `client_2`, etc.)
- Methods are registered via `RegisterMethod(name, handler)` where handler is `Func<JsonElement?, object>`
- Built-in methods: `echo`, `getTime`, `add`, `getClients`, `ping`
- Supports broadcasting notifications to all connected clients via `BroadcastNotificationAsync()`
- Responses are only sent for requests with an `id` (not for notifications)
- Server can be stopped gracefully with `Stop()` method which disconnects all clients

### Client Architecture (JsonRpcClient.cs)

- Implements `IDisposable` for proper resource cleanup
- Uses `TcpClient` to connect to server via `ConnectAsync(host, port)`
- Maintains pending requests in `ConcurrentDictionary<object, TaskCompletionSource<JsonRpcResponse>>`
- Request IDs are integers generated by `Interlocked.Increment` (thread-safe)
- Response matching handles `JsonElement` wrapping of numeric IDs
- Background receive loop processes responses and notifications
- Two call methods: `CallAsync<T>()` for typed responses and `CallAsync()` for object responses
- `NotifyAsync()` sends notifications without expecting responses
- Notifications from server trigger `NotificationReceived` event
- Connection status available via `IsConnected` property
- Supports configurable timeouts for requests (default 30 seconds)
- Use `Disconnect()` or `Dispose()` to cleanly close connection

### Key Implementation Details

1. **ID Handling**: The client uses integer IDs but must handle them as `JsonElement` when deserializing responses. The `ProcessResponse` method (JsonRpcClient.cs:89-133) extracts the integer value from `JsonElement` for dictionary lookups.

2. **Namespace Usage**: When working with the library:
   - Use `using Voltaic;` for all types (JsonRpcRequest, JsonRpcResponse, JsonRpcError, JsonRpcServer, JsonRpcClient)

3. **Connection Management**:
   - Server handles disconnections in `HandleClientAsync` finally block (JsonRpcServer.cs:137-142)
   - Client maintains `isConnected` flag synchronized with connection state
   - Pending requests are cancelled on disconnect

4. **Method Registration**: Server methods receive `JsonElement?` parameters and must use `TryGetProperty()` to extract typed values safely.

5. **Message Framing**: The `MessageFraming` class (internal static) provides LSP-style message framing:
   - Format: `Content-Length: {size}\r\n\r\n{json_body}`
   - `ReadMessageAsync()` handles partial reads, buffering, and multiple messages
   - `WriteMessageAsync()` frames messages with Content-Length header
   - Supports optional Content-Type header
   - Note: Currently uses tuples for return values (should be refactored per coding standards)

## Package Information

The Voltaic library is configured for NuGet package generation:
- Author: Joel Christner
- Target framework: .NET 8.0
- `GeneratePackageOnBuild` is enabled

## Coding Standards and Style Guidelines

**THESE RULES MUST BE FOLLOWED STRICTLY**

### Namespace and Using Statements

- Namespace declaration must always be at the top of the file
- Using statements must be contained INSIDE the namespace block
- All Microsoft and standard system library usings must be first, in alphabetical order
- Other using statements follow, also in alphabetical order

Example:
```csharp
namespace Voltaic
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;
    using ThirdPartyLib;
}
```

### Documentation Requirements

- All public members, constructors, and public methods MUST have XML documentation comments
- NO code documentation should be applied to private members or private methods
- Document nullability in XML comments
- Document thread safety guarantees in XML comments
- Document which exceptions public methods can throw using `/// <exception>` tags
- Document default values, minimum values, and maximum values where appropriate
- Specify what different values mean or what effect they may have

### Member Naming and Declaration

- Private class member variable names MUST start with an underscore and then be Pascal cased
  - Correct: `_FooBar`, `_TcpClient`, `_IsConnected`
  - Incorrect: `_fooBar`, `fooBar`, `tcpClient`
- All public members should have explicit getters and setters using backing variables when value requires range or null validation
- Do NOT use `var` when defining variables - use the actual type explicitly
  - Correct: `List<string> items = new List<string>();`
  - Incorrect: `var items = new List<string>();`
- Avoid using constant values for things that developers may later want to configure
  - Instead use a public member with a backing private member set to a reasonable default

### Type Usage and Patterns

- **Do NOT use tuples unless absolutely necessary** - they are strongly discouraged
- Use specific exception types rather than generic `Exception`
- Always include meaningful error messages with context
- Consider using custom exception types for domain-specific errors
- Use exception filters when appropriate: `catch (SqlException ex) when (ex.Number == 2601)`
- Use nullable reference types (ensure `<Nullable>enable</Nullable>` in project files)
- Validate input parameters with guard clauses at method start
- Use `ArgumentNullException.ThrowIfNull()` for .NET 6+ or manual null checks
- Consider using the Result pattern or Option/Maybe types for methods that can fail
- Proactively identify and eliminate any situations in code where null might cause exceptions

### Asynchronous Programming

- Async calls should use `.ConfigureAwait(false)` where appropriate
- Every async method should accept a `CancellationToken` as an input parameter, unless:
  - The class has a `CancellationToken` as a class member, OR
  - The class has a `CancellationTokenSource` as a class member
- Async calls should check whether cancellation has been requested at appropriate places using `token.ThrowIfCancellationRequested()` or checking `token.IsCancellationRequested`
- When implementing a method that returns an `IEnumerable`, also create an async variant that includes a `CancellationToken`

### Resource Management

- Implement `IDisposable`/`IAsyncDisposable` when holding unmanaged resources or disposable objects
- Use `using` statements or `using` declarations for `IDisposable` objects
- Follow the full Dispose pattern with `protected virtual void Dispose(bool disposing)`
- Always call `base.Dispose()` in derived classes

### Thread Safety

- Use `Interlocked` operations for simple atomic operations
- Prefer `ReaderWriterLockSlim` over `lock` for read-heavy scenarios

### LINQ and Collections

- Prefer LINQ methods over manual loops when readability is not compromised
- Use `.Any()` instead of `.Count() > 0` for existence checks
- Be aware of multiple enumeration issues - consider `.ToList()` when needed
- Use `.FirstOrDefault()` with null checks rather than `.First()` when element might not exist

### File Organization

- Limit each file to containing exactly one class OR exactly one enum
- Do NOT nest multiple classes or multiple enums in a single file
- Regions for Public-Members, Private-Members, Constructors-and-Factories, Public-Methods, and Private-Methods are NOT required for small files under 500 lines

### Library Code Restrictions

- **Ensure NO `Console.WriteLine` statements are added to library code**
- Use logging abstractions, events, or delegates instead for library diagnostic output
- Test applications (Test.Server, Test.Client) may use console output freely

### SQL and External Dependencies

- If manual SQL string construction is present, there is likely a good reason - assume it's intentional
- Do not make assumptions about class members or methods on opaque classes - ask for implementation details

### Documentation and Maintenance

- If a README exists, analyze it and ensure it is accurate
- Compile the code and ensure it is free of errors and warnings to the best of your ability

## Current Code Status

**Note**: Some existing code in the repository does not yet fully conform to these standards:
- Private member names in `JsonRpcClient.cs` and `JsonRpcServer.cs` use camelCase (e.g., `tcpClient`, `stream`) instead of PascalCase with underscore prefix (e.g., `_TcpClient`, `_Stream`)
- `MessageFraming.cs` uses tuples extensively for return values, which should be refactored to custom types or classes
- Some uses of `var` exist in the codebase that should be replaced with explicit types

When modifying existing code, update it to follow these standards. When creating new code, strictly adhere to all standards from the start.
